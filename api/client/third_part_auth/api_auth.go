/*
微信第三方平台授权相关接口

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package third_part_auth

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// AuthApiService AuthApi service
type AuthApiService service

type ApiComponentApiAuthorizerTokenPostRequest struct {
	ctx                    context.Context
	ApiService             *AuthApiService
	componentAccessToken   *string
	authorizerTokenRequest *AuthorizerTokenRequest
}

// 第三方平台component_access_token，不是authorizer_access_token
func (r ApiComponentApiAuthorizerTokenPostRequest) ComponentAccessToken(componentAccessToken string) ApiComponentApiAuthorizerTokenPostRequest {
	r.componentAccessToken = &componentAccessToken
	return r
}

func (r ApiComponentApiAuthorizerTokenPostRequest) AuthorizerTokenRequest(authorizerTokenRequest AuthorizerTokenRequest) ApiComponentApiAuthorizerTokenPostRequest {
	r.authorizerTokenRequest = &authorizerTokenRequest
	return r
}

func (r ApiComponentApiAuthorizerTokenPostRequest) Execute() (*AuthorizerTokenResponse, *http.Response, error) {
	return r.ApiService.ComponentApiAuthorizerTokenPostExecute(r)
}

/*
ComponentApiAuthorizerTokenPost 获取/刷新接口调用令牌

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiComponentApiAuthorizerTokenPostRequest
*/
func (a *AuthApiService) ComponentApiAuthorizerTokenPost(ctx context.Context) ApiComponentApiAuthorizerTokenPostRequest {
	return ApiComponentApiAuthorizerTokenPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthorizerTokenResponse
func (a *AuthApiService) ComponentApiAuthorizerTokenPostExecute(r ApiComponentApiAuthorizerTokenPostRequest) (*AuthorizerTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthorizerTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.ComponentApiAuthorizerTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/component/api_authorizer_token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentAccessToken == nil {
		return localVarReturnValue, nil, reportError("componentAccessToken is required and must be specified")
	}
	if r.authorizerTokenRequest == nil {
		return localVarReturnValue, nil, reportError("authorizerTokenRequest is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "component_access_token", r.componentAccessToken, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authorizerTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentApiComponentTokenPostRequest struct {
	ctx                   context.Context
	ApiService            *AuthApiService
	componentTokenRequest *ComponentTokenRequest
}

func (r ApiComponentApiComponentTokenPostRequest) ComponentTokenRequest(componentTokenRequest ComponentTokenRequest) ApiComponentApiComponentTokenPostRequest {
	r.componentTokenRequest = &componentTokenRequest
	return r
}

func (r ApiComponentApiComponentTokenPostRequest) Execute() (*ComponentTokenResponse, *http.Response, error) {
	return r.ApiService.ComponentApiComponentTokenPostExecute(r)
}

/*
ComponentApiComponentTokenPost 令牌

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiComponentApiComponentTokenPostRequest
*/
func (a *AuthApiService) ComponentApiComponentTokenPost(ctx context.Context) ApiComponentApiComponentTokenPostRequest {
	return ApiComponentApiComponentTokenPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ComponentTokenResponse
func (a *AuthApiService) ComponentApiComponentTokenPostExecute(r ApiComponentApiComponentTokenPostRequest) (*ComponentTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.ComponentApiComponentTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/component/api_component_token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentTokenRequest == nil {
		return localVarReturnValue, nil, reportError("componentTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentApiCreatePreauthcodePostRequest struct {
	ctx                      context.Context
	ApiService               *AuthApiService
	componentAccessToken     *string
	createPreauthcodeRequest *CreatePreauthcodeRequest
}

// 第三方平台component_access_token，不是authorizer_access_token
func (r ApiComponentApiCreatePreauthcodePostRequest) ComponentAccessToken(componentAccessToken string) ApiComponentApiCreatePreauthcodePostRequest {
	r.componentAccessToken = &componentAccessToken
	return r
}

func (r ApiComponentApiCreatePreauthcodePostRequest) CreatePreauthcodeRequest(createPreauthcodeRequest CreatePreauthcodeRequest) ApiComponentApiCreatePreauthcodePostRequest {
	r.createPreauthcodeRequest = &createPreauthcodeRequest
	return r
}

func (r ApiComponentApiCreatePreauthcodePostRequest) Execute() (*CreatePreauthcodeResponse, *http.Response, error) {
	return r.ApiService.ComponentApiCreatePreauthcodePostExecute(r)
}

/*
ComponentApiCreatePreauthcodePost 预授权码

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiComponentApiCreatePreauthcodePostRequest
*/
func (a *AuthApiService) ComponentApiCreatePreauthcodePost(ctx context.Context) ApiComponentApiCreatePreauthcodePostRequest {
	return ApiComponentApiCreatePreauthcodePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreatePreauthcodeResponse
func (a *AuthApiService) ComponentApiCreatePreauthcodePostExecute(r ApiComponentApiCreatePreauthcodePostRequest) (*CreatePreauthcodeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreatePreauthcodeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.ComponentApiCreatePreauthcodePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/component/api_create_preauthcode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentAccessToken == nil {
		return localVarReturnValue, nil, reportError("componentAccessToken is required and must be specified")
	}
	if r.createPreauthcodeRequest == nil {
		return localVarReturnValue, nil, reportError("createPreauthcodeRequest is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "component_access_token", r.componentAccessToken, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPreauthcodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentApiGetAuthorizerInfoPostRequest struct {
	ctx                      context.Context
	ApiService               *AuthApiService
	componentAccessToken     *string
	getAuthorizerInfoRequest *GetAuthorizerInfoRequest
}

// 第三方平台component_access_token，不是authorizer_access_token
func (r ApiComponentApiGetAuthorizerInfoPostRequest) ComponentAccessToken(componentAccessToken string) ApiComponentApiGetAuthorizerInfoPostRequest {
	r.componentAccessToken = &componentAccessToken
	return r
}

func (r ApiComponentApiGetAuthorizerInfoPostRequest) GetAuthorizerInfoRequest(getAuthorizerInfoRequest GetAuthorizerInfoRequest) ApiComponentApiGetAuthorizerInfoPostRequest {
	r.getAuthorizerInfoRequest = &getAuthorizerInfoRequest
	return r
}

func (r ApiComponentApiGetAuthorizerInfoPostRequest) Execute() (*GetAuthorizerInfoResponse, *http.Response, error) {
	return r.ApiService.ComponentApiGetAuthorizerInfoPostExecute(r)
}

/*
ComponentApiGetAuthorizerInfoPost 获取授权方的帐号基本信息

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiComponentApiGetAuthorizerInfoPostRequest
*/
func (a *AuthApiService) ComponentApiGetAuthorizerInfoPost(ctx context.Context) ApiComponentApiGetAuthorizerInfoPostRequest {
	return ApiComponentApiGetAuthorizerInfoPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetAuthorizerInfoResponse
func (a *AuthApiService) ComponentApiGetAuthorizerInfoPostExecute(r ApiComponentApiGetAuthorizerInfoPostRequest) (*GetAuthorizerInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAuthorizerInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.ComponentApiGetAuthorizerInfoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/component/api_get_authorizer_info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentAccessToken == nil {
		return localVarReturnValue, nil, reportError("componentAccessToken is required and must be specified")
	}
	if r.getAuthorizerInfoRequest == nil {
		return localVarReturnValue, nil, reportError("getAuthorizerInfoRequest is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "component_access_token", r.componentAccessToken, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getAuthorizerInfoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentApiQueryAuthPostRequest struct {
	ctx                  context.Context
	ApiService           *AuthApiService
	componentAccessToken *string
	queryAuthRequest     *QueryAuthRequest
}

// 第三方平台component_access_token，不是authorizer_access_token
func (r ApiComponentApiQueryAuthPostRequest) ComponentAccessToken(componentAccessToken string) ApiComponentApiQueryAuthPostRequest {
	r.componentAccessToken = &componentAccessToken
	return r
}

func (r ApiComponentApiQueryAuthPostRequest) QueryAuthRequest(queryAuthRequest QueryAuthRequest) ApiComponentApiQueryAuthPostRequest {
	r.queryAuthRequest = &queryAuthRequest
	return r
}

func (r ApiComponentApiQueryAuthPostRequest) Execute() (*QueryAuthResponse, *http.Response, error) {
	return r.ApiService.ComponentApiQueryAuthPostExecute(r)
}

/*
ComponentApiQueryAuthPost 使用授权码获取授权信息

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiComponentApiQueryAuthPostRequest
*/
func (a *AuthApiService) ComponentApiQueryAuthPost(ctx context.Context) ApiComponentApiQueryAuthPostRequest {
	return ApiComponentApiQueryAuthPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return QueryAuthResponse
func (a *AuthApiService) ComponentApiQueryAuthPostExecute(r ApiComponentApiQueryAuthPostRequest) (*QueryAuthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *QueryAuthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.ComponentApiQueryAuthPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/component/api_query_auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentAccessToken == nil {
		return localVarReturnValue, nil, reportError("componentAccessToken is required and must be specified")
	}
	if r.queryAuthRequest == nil {
		return localVarReturnValue, nil, reportError("queryAuthRequest is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "component_access_token", r.componentAccessToken, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryAuthRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComponentApiStartPushTicketPostRequest struct {
	ctx                    context.Context
	ApiService             *AuthApiService
	startPushTicketRequest *StartPushTicketRequest
}

func (r ApiComponentApiStartPushTicketPostRequest) StartPushTicketRequest(startPushTicketRequest StartPushTicketRequest) ApiComponentApiStartPushTicketPostRequest {
	r.startPushTicketRequest = &startPushTicketRequest
	return r
}

func (r ApiComponentApiStartPushTicketPostRequest) Execute() (*StartPushTicketResponse, *http.Response, error) {
	return r.ApiService.ComponentApiStartPushTicketPostExecute(r)
}

/*
ComponentApiStartPushTicketPost 启动ticket推送服务

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiComponentApiStartPushTicketPostRequest
*/
func (a *AuthApiService) ComponentApiStartPushTicketPost(ctx context.Context) ApiComponentApiStartPushTicketPostRequest {
	return ApiComponentApiStartPushTicketPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StartPushTicketResponse
func (a *AuthApiService) ComponentApiStartPushTicketPostExecute(r ApiComponentApiStartPushTicketPostRequest) (*StartPushTicketResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StartPushTicketResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthApiService.ComponentApiStartPushTicketPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/component/api_start_push_ticket"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startPushTicketRequest == nil {
		return localVarReturnValue, nil, reportError("startPushTicketRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.startPushTicketRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
